// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ClusterAutoscaleInitParameters struct {
	MaxWorkers *float64 `json:"maxWorkers,omitempty" tf:"max_workers,omitempty"`

	MinWorkers *float64 `json:"minWorkers,omitempty" tf:"min_workers,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type ClusterAutoscaleObservation struct {
	MaxWorkers *float64 `json:"maxWorkers,omitempty" tf:"max_workers,omitempty"`

	MinWorkers *float64 `json:"minWorkers,omitempty" tf:"min_workers,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type ClusterAutoscaleParameters struct {

	// +kubebuilder:validation:Optional
	MaxWorkers *float64 `json:"maxWorkers" tf:"max_workers,omitempty"`

	// +kubebuilder:validation:Optional
	MinWorkers *float64 `json:"minWorkers" tf:"min_workers,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type ClusterAwsAttributesInitParameters struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	EBSVolumeCount *float64 `json:"ebsVolumeCount,omitempty" tf:"ebs_volume_count,omitempty"`

	EBSVolumeIops *float64 `json:"ebsVolumeIops,omitempty" tf:"ebs_volume_iops,omitempty"`

	EBSVolumeSize *float64 `json:"ebsVolumeSize,omitempty" tf:"ebs_volume_size,omitempty"`

	EBSVolumeThroughput *float64 `json:"ebsVolumeThroughput,omitempty" tf:"ebs_volume_throughput,omitempty"`

	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	InstanceProfileArn *string `json:"instanceProfileArn,omitempty" tf:"instance_profile_arn,omitempty"`

	SpotBidPricePercent *float64 `json:"spotBidPricePercent,omitempty" tf:"spot_bid_price_percent,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterAwsAttributesObservation struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	EBSVolumeCount *float64 `json:"ebsVolumeCount,omitempty" tf:"ebs_volume_count,omitempty"`

	EBSVolumeIops *float64 `json:"ebsVolumeIops,omitempty" tf:"ebs_volume_iops,omitempty"`

	EBSVolumeSize *float64 `json:"ebsVolumeSize,omitempty" tf:"ebs_volume_size,omitempty"`

	EBSVolumeThroughput *float64 `json:"ebsVolumeThroughput,omitempty" tf:"ebs_volume_throughput,omitempty"`

	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	InstanceProfileArn *string `json:"instanceProfileArn,omitempty" tf:"instance_profile_arn,omitempty"`

	SpotBidPricePercent *float64 `json:"spotBidPricePercent,omitempty" tf:"spot_bid_price_percent,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterAwsAttributesParameters struct {

	// +kubebuilder:validation:Optional
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeCount *float64 `json:"ebsVolumeCount,omitempty" tf:"ebs_volume_count,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeIops *float64 `json:"ebsVolumeIops,omitempty" tf:"ebs_volume_iops,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeSize *float64 `json:"ebsVolumeSize,omitempty" tf:"ebs_volume_size,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeThroughput *float64 `json:"ebsVolumeThroughput,omitempty" tf:"ebs_volume_throughput,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	// +kubebuilder:validation:Optional
	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceProfileArn *string `json:"instanceProfileArn,omitempty" tf:"instance_profile_arn,omitempty"`

	// +kubebuilder:validation:Optional
	SpotBidPricePercent *float64 `json:"spotBidPricePercent,omitempty" tf:"spot_bid_price_percent,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterAzureAttributesInitParameters struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	LogAnalyticsInfo []ClusterAzureAttributesLogAnalyticsInfoInitParameters `json:"logAnalyticsInfo,omitempty" tf:"log_analytics_info,omitempty"`

	SpotBidMaxPrice *float64 `json:"spotBidMaxPrice,omitempty" tf:"spot_bid_max_price,omitempty"`
}

type ClusterAzureAttributesLogAnalyticsInfoInitParameters struct {
	LogAnalyticsPrimaryKey *string `json:"logAnalyticsPrimaryKey,omitempty" tf:"log_analytics_primary_key,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	LogAnalyticsWorkspaceID *string `json:"logAnalyticsWorkspaceId,omitempty" tf:"log_analytics_workspace_id,omitempty"`
}

type ClusterAzureAttributesLogAnalyticsInfoObservation struct {
	LogAnalyticsPrimaryKey *string `json:"logAnalyticsPrimaryKey,omitempty" tf:"log_analytics_primary_key,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	LogAnalyticsWorkspaceID *string `json:"logAnalyticsWorkspaceId,omitempty" tf:"log_analytics_workspace_id,omitempty"`
}

type ClusterAzureAttributesLogAnalyticsInfoParameters struct {

	// +kubebuilder:validation:Optional
	LogAnalyticsPrimaryKey *string `json:"logAnalyticsPrimaryKey,omitempty" tf:"log_analytics_primary_key,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	LogAnalyticsWorkspaceID *string `json:"logAnalyticsWorkspaceId,omitempty" tf:"log_analytics_workspace_id,omitempty"`
}

type ClusterAzureAttributesObservation struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	LogAnalyticsInfo []ClusterAzureAttributesLogAnalyticsInfoObservation `json:"logAnalyticsInfo,omitempty" tf:"log_analytics_info,omitempty"`

	SpotBidMaxPrice *float64 `json:"spotBidMaxPrice,omitempty" tf:"spot_bid_max_price,omitempty"`
}

type ClusterAzureAttributesParameters struct {

	// +kubebuilder:validation:Optional
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	// +kubebuilder:validation:Optional
	FirstOnDemand *float64 `json:"firstOnDemand,omitempty" tf:"first_on_demand,omitempty"`

	// +kubebuilder:validation:Optional
	LogAnalyticsInfo []ClusterAzureAttributesLogAnalyticsInfoParameters `json:"logAnalyticsInfo,omitempty" tf:"log_analytics_info,omitempty"`

	// +kubebuilder:validation:Optional
	SpotBidMaxPrice *float64 `json:"spotBidMaxPrice,omitempty" tf:"spot_bid_max_price,omitempty"`
}

type ClusterClusterLogConfDbfsInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterClusterLogConfDbfsObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterClusterLogConfDbfsParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterClusterLogConfInitParameters struct {
	Dbfs []ClusterClusterLogConfDbfsInitParameters `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	S3 []ClusterClusterLogConfS3InitParameters `json:"s3,omitempty" tf:"s3,omitempty"`
}

type ClusterClusterLogConfObservation struct {
	Dbfs []ClusterClusterLogConfDbfsObservation `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	S3 []ClusterClusterLogConfS3Observation `json:"s3,omitempty" tf:"s3,omitempty"`
}

type ClusterClusterLogConfParameters struct {

	// +kubebuilder:validation:Optional
	Dbfs []ClusterClusterLogConfDbfsParameters `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	// +kubebuilder:validation:Optional
	S3 []ClusterClusterLogConfS3Parameters `json:"s3,omitempty" tf:"s3,omitempty"`
}

type ClusterClusterLogConfS3InitParameters struct {
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`

	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterClusterLogConfS3Observation struct {
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`

	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterClusterLogConfS3Parameters struct {

	// +kubebuilder:validation:Optional
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`

	// +kubebuilder:validation:Optional
	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	// +kubebuilder:validation:Optional
	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	// +kubebuilder:validation:Optional
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterGCPAttributesInitParameters struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	GoogleServiceAccount *string `json:"googleServiceAccount,omitempty" tf:"google_service_account,omitempty"`

	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterGCPAttributesObservation struct {
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	GoogleServiceAccount *string `json:"googleServiceAccount,omitempty" tf:"google_service_account,omitempty"`

	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterGCPAttributesParameters struct {

	// +kubebuilder:validation:Optional
	Availability *string `json:"availability,omitempty" tf:"availability,omitempty"`

	// +kubebuilder:validation:Optional
	GoogleServiceAccount *string `json:"googleServiceAccount,omitempty" tf:"google_service_account,omitempty"`

	// +kubebuilder:validation:Optional
	LocalSsdCount *float64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ClusterInitScriptsAbfssInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsAbfssObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsAbfssParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterInitScriptsDbfsInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsDbfsObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsDbfsParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterInitScriptsFileInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsFileObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsFileParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterInitScriptsGcsInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsGcsObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsGcsParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterInitScriptsInitParameters struct {
	Abfss []ClusterInitScriptsAbfssInitParameters `json:"abfss,omitempty" tf:"abfss,omitempty"`

	Dbfs []ClusterInitScriptsDbfsInitParameters `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	File []ClusterInitScriptsFileInitParameters `json:"file,omitempty" tf:"file,omitempty"`

	Gcs []ClusterInitScriptsGcsInitParameters `json:"gcs,omitempty" tf:"gcs,omitempty"`

	S3 []ClusterInitScriptsS3InitParameters `json:"s3,omitempty" tf:"s3,omitempty"`

	Volumes []ClusterInitScriptsVolumesInitParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`

	Workspace []ClusterInitScriptsWorkspaceInitParameters `json:"workspace,omitempty" tf:"workspace,omitempty"`
}

type ClusterInitScriptsObservation struct {
	Abfss []ClusterInitScriptsAbfssObservation `json:"abfss,omitempty" tf:"abfss,omitempty"`

	Dbfs []ClusterInitScriptsDbfsObservation `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	File []ClusterInitScriptsFileObservation `json:"file,omitempty" tf:"file,omitempty"`

	Gcs []ClusterInitScriptsGcsObservation `json:"gcs,omitempty" tf:"gcs,omitempty"`

	S3 []ClusterInitScriptsS3Observation `json:"s3,omitempty" tf:"s3,omitempty"`

	Volumes []ClusterInitScriptsVolumesObservation `json:"volumes,omitempty" tf:"volumes,omitempty"`

	Workspace []ClusterInitScriptsWorkspaceObservation `json:"workspace,omitempty" tf:"workspace,omitempty"`
}

type ClusterInitScriptsParameters struct {

	// +kubebuilder:validation:Optional
	Abfss []ClusterInitScriptsAbfssParameters `json:"abfss,omitempty" tf:"abfss,omitempty"`

	// +kubebuilder:validation:Optional
	Dbfs []ClusterInitScriptsDbfsParameters `json:"dbfs,omitempty" tf:"dbfs,omitempty"`

	// +kubebuilder:validation:Optional
	File []ClusterInitScriptsFileParameters `json:"file,omitempty" tf:"file,omitempty"`

	// +kubebuilder:validation:Optional
	Gcs []ClusterInitScriptsGcsParameters `json:"gcs,omitempty" tf:"gcs,omitempty"`

	// +kubebuilder:validation:Optional
	S3 []ClusterInitScriptsS3Parameters `json:"s3,omitempty" tf:"s3,omitempty"`

	// +kubebuilder:validation:Optional
	Volumes []ClusterInitScriptsVolumesParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`

	// +kubebuilder:validation:Optional
	Workspace []ClusterInitScriptsWorkspaceParameters `json:"workspace,omitempty" tf:"workspace,omitempty"`
}

type ClusterInitScriptsS3InitParameters struct {
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`

	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterInitScriptsS3Observation struct {
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`

	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterInitScriptsS3Parameters struct {

	// +kubebuilder:validation:Optional
	CannedACL *string `json:"cannedAcl,omitempty" tf:"canned_acl,omitempty"`

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`

	// +kubebuilder:validation:Optional
	EnableEncryption *bool `json:"enableEncryption,omitempty" tf:"enable_encryption,omitempty"`

	// +kubebuilder:validation:Optional
	EncryptionType *string `json:"encryptionType,omitempty" tf:"encryption_type,omitempty"`

	// +kubebuilder:validation:Optional
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKey *string `json:"kmsKey,omitempty" tf:"kms_key,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ClusterInitScriptsVolumesInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsVolumesObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsVolumesParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type ClusterInitScriptsWorkspaceInitParameters struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsWorkspaceObservation struct {
	Destination *string `json:"destination,omitempty" tf:"destination,omitempty"`
}

type ClusterInitScriptsWorkspaceParameters struct {

	// +kubebuilder:validation:Optional
	Destination *string `json:"destination" tf:"destination,omitempty"`
}

type CronInitParameters struct {
	QuartzCronSchedule *string `json:"quartzCronSchedule,omitempty" tf:"quartz_cron_schedule,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	TimezoneID *string `json:"timezoneId,omitempty" tf:"timezone_id,omitempty"`
}

type CronObservation struct {
	QuartzCronSchedule *string `json:"quartzCronSchedule,omitempty" tf:"quartz_cron_schedule,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	TimezoneID *string `json:"timezoneId,omitempty" tf:"timezone_id,omitempty"`
}

type CronParameters struct {

	// +kubebuilder:validation:Optional
	QuartzCronSchedule *string `json:"quartzCronSchedule,omitempty" tf:"quartz_cron_schedule,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	TimezoneID *string `json:"timezoneId,omitempty" tf:"timezone_id,omitempty"`
}

type FiltersInitParameters struct {

	// Paths to exclude.
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// Paths to include.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type FiltersObservation struct {

	// Paths to exclude.
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// Paths to include.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type FiltersParameters struct {

	// Paths to exclude.
	// +kubebuilder:validation:Optional
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// Paths to include.
	// +kubebuilder:validation:Optional
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type GatewayDefinitionInitParameters struct {

	// Immutable. The Unity Catalog connection this gateway pipeline uses to communicate with the source.
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// Required, Immutable. The name of the catalog for the gateway pipeline's storage location.
	GatewayStorageCatalog *string `json:"gatewayStorageCatalog,omitempty" tf:"gateway_storage_catalog,omitempty"`

	// Required. The Unity Catalog-compatible naming for the gateway storage location. This is the destination to use for the data that is extracted by the gateway. Delta Live Tables system will automatically create the storage location under the catalog and schema.
	GatewayStorageName *string `json:"gatewayStorageName,omitempty" tf:"gateway_storage_name,omitempty"`

	// Required, Immutable. The name of the schema for the gateway pipelines's storage location.
	GatewayStorageSchema *string `json:"gatewayStorageSchema,omitempty" tf:"gateway_storage_schema,omitempty"`
}

type GatewayDefinitionObservation struct {

	// Immutable. The Unity Catalog connection this gateway pipeline uses to communicate with the source.
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// Required, Immutable. The name of the catalog for the gateway pipeline's storage location.
	GatewayStorageCatalog *string `json:"gatewayStorageCatalog,omitempty" tf:"gateway_storage_catalog,omitempty"`

	// Required. The Unity Catalog-compatible naming for the gateway storage location. This is the destination to use for the data that is extracted by the gateway. Delta Live Tables system will automatically create the storage location under the catalog and schema.
	GatewayStorageName *string `json:"gatewayStorageName,omitempty" tf:"gateway_storage_name,omitempty"`

	// Required, Immutable. The name of the schema for the gateway pipelines's storage location.
	GatewayStorageSchema *string `json:"gatewayStorageSchema,omitempty" tf:"gateway_storage_schema,omitempty"`
}

type GatewayDefinitionParameters struct {

	// Immutable. The Unity Catalog connection this gateway pipeline uses to communicate with the source.
	// +kubebuilder:validation:Optional
	ConnectionID *string `json:"connectionId,omitempty" tf:"connection_id,omitempty"`

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	// +kubebuilder:validation:Optional
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// Required, Immutable. The name of the catalog for the gateway pipeline's storage location.
	// +kubebuilder:validation:Optional
	GatewayStorageCatalog *string `json:"gatewayStorageCatalog,omitempty" tf:"gateway_storage_catalog,omitempty"`

	// Required. The Unity Catalog-compatible naming for the gateway storage location. This is the destination to use for the data that is extracted by the gateway. Delta Live Tables system will automatically create the storage location under the catalog and schema.
	// +kubebuilder:validation:Optional
	GatewayStorageName *string `json:"gatewayStorageName,omitempty" tf:"gateway_storage_name,omitempty"`

	// Required, Immutable. The name of the schema for the gateway pipelines's storage location.
	// +kubebuilder:validation:Optional
	GatewayStorageSchema *string `json:"gatewayStorageSchema,omitempty" tf:"gateway_storage_schema,omitempty"`
}

type IngestionDefinitionInitParameters struct {

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// Immutable. Identifier for the ingestion gateway used by this ingestion pipeline to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	IngestionGatewayID *string `json:"ingestionGatewayId,omitempty" tf:"ingestion_gateway_id,omitempty"`

	// Required. Settings specifying tables to replicate and the destination for the replicated tables.
	Objects []ObjectsInitParameters `json:"objects,omitempty" tf:"objects,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration []IngestionDefinitionTableConfigurationInitParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type IngestionDefinitionObservation struct {

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// Immutable. Identifier for the ingestion gateway used by this ingestion pipeline to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	IngestionGatewayID *string `json:"ingestionGatewayId,omitempty" tf:"ingestion_gateway_id,omitempty"`

	// Required. Settings specifying tables to replicate and the destination for the replicated tables.
	Objects []ObjectsObservation `json:"objects,omitempty" tf:"objects,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration []IngestionDefinitionTableConfigurationObservation `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type IngestionDefinitionParameters struct {

	// Immutable. The Unity Catalog connection this ingestion pipeline uses to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	// +kubebuilder:validation:Optional
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// Immutable. Identifier for the ingestion gateway used by this ingestion pipeline to communicate with the source. Specify either ingestion_gateway_id or connection_name.
	// +kubebuilder:validation:Optional
	IngestionGatewayID *string `json:"ingestionGatewayId,omitempty" tf:"ingestion_gateway_id,omitempty"`

	// Required. Settings specifying tables to replicate and the destination for the replicated tables.
	// +kubebuilder:validation:Optional
	Objects []ObjectsParameters `json:"objects,omitempty" tf:"objects,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	// +kubebuilder:validation:Optional
	TableConfiguration []IngestionDefinitionTableConfigurationParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type IngestionDefinitionTableConfigurationInitParameters struct {
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type IngestionDefinitionTableConfigurationObservation struct {
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type IngestionDefinitionTableConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	// +kubebuilder:validation:Optional
	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	// +kubebuilder:validation:Optional
	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	// +kubebuilder:validation:Optional
	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type LatestUpdatesInitParameters struct {
	CreationTime *string `json:"creationTime,omitempty" tf:"creation_time,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	UpdateID *string `json:"updateId,omitempty" tf:"update_id,omitempty"`
}

type LatestUpdatesObservation struct {
	CreationTime *string `json:"creationTime,omitempty" tf:"creation_time,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	UpdateID *string `json:"updateId,omitempty" tf:"update_id,omitempty"`
}

type LatestUpdatesParameters struct {

	// +kubebuilder:validation:Optional
	CreationTime *string `json:"creationTime,omitempty" tf:"creation_time,omitempty"`

	// +kubebuilder:validation:Optional
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	UpdateID *string `json:"updateId,omitempty" tf:"update_id,omitempty"`
}

type LibraryFileInitParameters struct {
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type LibraryFileObservation struct {
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type LibraryFileParameters struct {

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type ManualInitParameters struct {
}

type ManualObservation struct {
}

type ManualParameters struct {
}

type NotebookInitParameters struct {
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type NotebookObservation struct {
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type NotebookParameters struct {

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type NotificationInitParameters struct {

	// empty list of alert types. Right now following alert types are supported, consult documentation for actual list
	Alerts []*string `json:"alerts,omitempty" tf:"alerts,omitempty"`

	// empty list of emails to notify.
	EmailRecipients []*string `json:"emailRecipients,omitempty" tf:"email_recipients,omitempty"`
}

type NotificationObservation struct {

	// empty list of alert types. Right now following alert types are supported, consult documentation for actual list
	Alerts []*string `json:"alerts,omitempty" tf:"alerts,omitempty"`

	// empty list of emails to notify.
	EmailRecipients []*string `json:"emailRecipients,omitempty" tf:"email_recipients,omitempty"`
}

type NotificationParameters struct {

	// empty list of alert types. Right now following alert types are supported, consult documentation for actual list
	// +kubebuilder:validation:Optional
	Alerts []*string `json:"alerts,omitempty" tf:"alerts,omitempty"`

	// empty list of emails to notify.
	// +kubebuilder:validation:Optional
	EmailRecipients []*string `json:"emailRecipients,omitempty" tf:"email_recipients,omitempty"`
}

type ObjectsInitParameters struct {
	Report []ReportInitParameters `json:"report,omitempty" tf:"report,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	Schema []SchemaInitParameters `json:"schema,omitempty" tf:"schema,omitempty"`

	Table []ObjectsTableInitParameters `json:"table,omitempty" tf:"table,omitempty"`
}

type ObjectsObservation struct {
	Report []ReportObservation `json:"report,omitempty" tf:"report,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	Schema []SchemaObservation `json:"schema,omitempty" tf:"schema,omitempty"`

	Table []ObjectsTableObservation `json:"table,omitempty" tf:"table,omitempty"`
}

type ObjectsParameters struct {

	// +kubebuilder:validation:Optional
	Report []ReportParameters `json:"report,omitempty" tf:"report,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	Schema []SchemaParameters `json:"schema,omitempty" tf:"schema,omitempty"`

	// +kubebuilder:validation:Optional
	Table []ObjectsTableParameters `json:"table,omitempty" tf:"table,omitempty"`
}

type ObjectsTableInitParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	SourceSchema *string `json:"sourceSchema,omitempty" tf:"source_schema,omitempty"`

	SourceTable *string `json:"sourceTable,omitempty" tf:"source_table,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration []TableTableConfigurationInitParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type ObjectsTableObservation struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	SourceSchema *string `json:"sourceSchema,omitempty" tf:"source_schema,omitempty"`

	SourceTable *string `json:"sourceTable,omitempty" tf:"source_table,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration []TableTableConfigurationObservation `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type ObjectsTableParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	SourceSchema *string `json:"sourceSchema,omitempty" tf:"source_schema,omitempty"`

	// +kubebuilder:validation:Optional
	SourceTable *string `json:"sourceTable,omitempty" tf:"source_table,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	// +kubebuilder:validation:Optional
	TableConfiguration []TableTableConfigurationParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type PipelineClusterInitParameters struct {
	ApplyPolicyDefaultValues *bool `json:"applyPolicyDefaultValues,omitempty" tf:"apply_policy_default_values,omitempty"`

	Autoscale []ClusterAutoscaleInitParameters `json:"autoscale,omitempty" tf:"autoscale,omitempty"`

	AwsAttributes []ClusterAwsAttributesInitParameters `json:"awsAttributes,omitempty" tf:"aws_attributes,omitempty"`

	AzureAttributes []ClusterAzureAttributesInitParameters `json:"azureAttributes,omitempty" tf:"azure_attributes,omitempty"`

	ClusterLogConf []ClusterClusterLogConfInitParameters `json:"clusterLogConf,omitempty" tf:"cluster_log_conf,omitempty"`

	// +mapType=granular
	CustomTags map[string]*string `json:"customTags,omitempty" tf:"custom_tags,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	DriverInstancePoolID *string `json:"driverInstancePoolId,omitempty" tf:"driver_instance_pool_id,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	DriverNodeTypeID *string `json:"driverNodeTypeId,omitempty" tf:"driver_node_type_id,omitempty"`

	EnableLocalDiskEncryption *bool `json:"enableLocalDiskEncryption,omitempty" tf:"enable_local_disk_encryption,omitempty"`

	GCPAttributes []ClusterGCPAttributesInitParameters `json:"gcpAttributes,omitempty" tf:"gcp_attributes,omitempty"`

	InitScripts []ClusterInitScriptsInitParameters `json:"initScripts,omitempty" tf:"init_scripts,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	InstancePoolID *string `json:"instancePoolId,omitempty" tf:"instance_pool_id,omitempty"`

	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	NodeTypeID *string `json:"nodeTypeId,omitempty" tf:"node_type_id,omitempty"`

	NumWorkers *float64 `json:"numWorkers,omitempty" tf:"num_workers,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	PolicyID *string `json:"policyId,omitempty" tf:"policy_id,omitempty"`

	SSHPublicKeys []*string `json:"sshPublicKeys,omitempty" tf:"ssh_public_keys,omitempty"`

	// +mapType=granular
	SparkConf map[string]*string `json:"sparkConf,omitempty" tf:"spark_conf,omitempty"`

	// +mapType=granular
	SparkEnvVars map[string]*string `json:"sparkEnvVars,omitempty" tf:"spark_env_vars,omitempty"`
}

type PipelineClusterObservation struct {
	ApplyPolicyDefaultValues *bool `json:"applyPolicyDefaultValues,omitempty" tf:"apply_policy_default_values,omitempty"`

	Autoscale []ClusterAutoscaleObservation `json:"autoscale,omitempty" tf:"autoscale,omitempty"`

	AwsAttributes []ClusterAwsAttributesObservation `json:"awsAttributes,omitempty" tf:"aws_attributes,omitempty"`

	AzureAttributes []ClusterAzureAttributesObservation `json:"azureAttributes,omitempty" tf:"azure_attributes,omitempty"`

	ClusterLogConf []ClusterClusterLogConfObservation `json:"clusterLogConf,omitempty" tf:"cluster_log_conf,omitempty"`

	// +mapType=granular
	CustomTags map[string]*string `json:"customTags,omitempty" tf:"custom_tags,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	DriverInstancePoolID *string `json:"driverInstancePoolId,omitempty" tf:"driver_instance_pool_id,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	DriverNodeTypeID *string `json:"driverNodeTypeId,omitempty" tf:"driver_node_type_id,omitempty"`

	EnableLocalDiskEncryption *bool `json:"enableLocalDiskEncryption,omitempty" tf:"enable_local_disk_encryption,omitempty"`

	GCPAttributes []ClusterGCPAttributesObservation `json:"gcpAttributes,omitempty" tf:"gcp_attributes,omitempty"`

	InitScripts []ClusterInitScriptsObservation `json:"initScripts,omitempty" tf:"init_scripts,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	InstancePoolID *string `json:"instancePoolId,omitempty" tf:"instance_pool_id,omitempty"`

	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	NodeTypeID *string `json:"nodeTypeId,omitempty" tf:"node_type_id,omitempty"`

	NumWorkers *float64 `json:"numWorkers,omitempty" tf:"num_workers,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	PolicyID *string `json:"policyId,omitempty" tf:"policy_id,omitempty"`

	SSHPublicKeys []*string `json:"sshPublicKeys,omitempty" tf:"ssh_public_keys,omitempty"`

	// +mapType=granular
	SparkConf map[string]*string `json:"sparkConf,omitempty" tf:"spark_conf,omitempty"`

	// +mapType=granular
	SparkEnvVars map[string]*string `json:"sparkEnvVars,omitempty" tf:"spark_env_vars,omitempty"`
}

type PipelineClusterParameters struct {

	// +kubebuilder:validation:Optional
	ApplyPolicyDefaultValues *bool `json:"applyPolicyDefaultValues,omitempty" tf:"apply_policy_default_values,omitempty"`

	// +kubebuilder:validation:Optional
	Autoscale []ClusterAutoscaleParameters `json:"autoscale,omitempty" tf:"autoscale,omitempty"`

	// +kubebuilder:validation:Optional
	AwsAttributes []ClusterAwsAttributesParameters `json:"awsAttributes,omitempty" tf:"aws_attributes,omitempty"`

	// +kubebuilder:validation:Optional
	AzureAttributes []ClusterAzureAttributesParameters `json:"azureAttributes,omitempty" tf:"azure_attributes,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterLogConf []ClusterClusterLogConfParameters `json:"clusterLogConf,omitempty" tf:"cluster_log_conf,omitempty"`

	// +kubebuilder:validation:Optional
	// +mapType=granular
	CustomTags map[string]*string `json:"customTags,omitempty" tf:"custom_tags,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	DriverInstancePoolID *string `json:"driverInstancePoolId,omitempty" tf:"driver_instance_pool_id,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	DriverNodeTypeID *string `json:"driverNodeTypeId,omitempty" tf:"driver_node_type_id,omitempty"`

	// +kubebuilder:validation:Optional
	EnableLocalDiskEncryption *bool `json:"enableLocalDiskEncryption,omitempty" tf:"enable_local_disk_encryption,omitempty"`

	// +kubebuilder:validation:Optional
	GCPAttributes []ClusterGCPAttributesParameters `json:"gcpAttributes,omitempty" tf:"gcp_attributes,omitempty"`

	// +kubebuilder:validation:Optional
	InitScripts []ClusterInitScriptsParameters `json:"initScripts,omitempty" tf:"init_scripts,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	InstancePoolID *string `json:"instancePoolId,omitempty" tf:"instance_pool_id,omitempty"`

	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	NodeTypeID *string `json:"nodeTypeId,omitempty" tf:"node_type_id,omitempty"`

	// +kubebuilder:validation:Optional
	NumWorkers *float64 `json:"numWorkers,omitempty" tf:"num_workers,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	PolicyID *string `json:"policyId,omitempty" tf:"policy_id,omitempty"`

	// +kubebuilder:validation:Optional
	SSHPublicKeys []*string `json:"sshPublicKeys,omitempty" tf:"ssh_public_keys,omitempty"`

	// +kubebuilder:validation:Optional
	// +mapType=granular
	SparkConf map[string]*string `json:"sparkConf,omitempty" tf:"spark_conf,omitempty"`

	// +kubebuilder:validation:Optional
	// +mapType=granular
	SparkEnvVars map[string]*string `json:"sparkEnvVars,omitempty" tf:"spark_env_vars,omitempty"`
}

type PipelineDeploymentInitParameters struct {

	// The deployment method that manages the pipeline.
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The path to the file containing metadata about the deployment.
	MetadataFilePath *string `json:"metadataFilePath,omitempty" tf:"metadata_file_path,omitempty"`
}

type PipelineDeploymentObservation struct {

	// The deployment method that manages the pipeline.
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The path to the file containing metadata about the deployment.
	MetadataFilePath *string `json:"metadataFilePath,omitempty" tf:"metadata_file_path,omitempty"`
}

type PipelineDeploymentParameters struct {

	// The deployment method that manages the pipeline.
	// +kubebuilder:validation:Optional
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The path to the file containing metadata about the deployment.
	// +kubebuilder:validation:Optional
	MetadataFilePath *string `json:"metadataFilePath,omitempty" tf:"metadata_file_path,omitempty"`
}

type PipelineInitParameters struct {

	// Optional boolean flag. If false, deployment will fail if name conflicts with that of another pipeline. default is false.
	AllowDuplicateNames *bool `json:"allowDuplicateNames,omitempty" tf:"allow_duplicate_names,omitempty"`

	// optional string specifying ID of the budget policy for this DLT pipeline.
	BudgetPolicyID *string `json:"budgetPolicyId,omitempty" tf:"budget_policy_id,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	Catalog *string `json:"catalog,omitempty" tf:"catalog,omitempty"`

	Cause *string `json:"cause,omitempty" tf:"cause,omitempty"`

	// optional name of the release channel for Spark version used by DLT pipeline.  Supported values are: CURRENT (default) and PREVIEW.
	Channel *string `json:"channel,omitempty" tf:"channel,omitempty"`

	// Clusters to run the pipeline. If none is specified, pipelines will automatically select a default cluster configuration for the pipeline. Please note that DLT pipeline clusters are supporting only subset of attributes as described in   Also, note that autoscale block is extended with the mode parameter that controls the autoscaling algorithm (possible values are ENHANCED for new, enhanced autoscaling algorithm, or LEGACY for old algorithm).
	Cluster []PipelineClusterInitParameters `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// An optional list of values to apply to the entire pipeline. Elements must be formatted as key:value pairs.
	// +mapType=granular
	Configuration map[string]*string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// A flag indicating whether to run the pipeline continuously. The default value is false.
	Continuous *bool `json:"continuous,omitempty" tf:"continuous,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	CreatorUserName *string `json:"creatorUserName,omitempty" tf:"creator_user_name,omitempty"`

	// Deployment type of this pipeline. Supports following attributes:
	Deployment []PipelineDeploymentInitParameters `json:"deployment,omitempty" tf:"deployment,omitempty"`

	// A flag indicating whether to run the pipeline in development mode. The default value is false.
	Development *bool `json:"development,omitempty" tf:"development,omitempty"`

	// optional name of the product edition. Supported values are: CORE, PRO, ADVANCED (default).  Not required when serverless is set to true.
	Edition *string `json:"edition,omitempty" tf:"edition,omitempty"`

	ExpectedLastModified *float64 `json:"expectedLastModified,omitempty" tf:"expected_last_modified,omitempty"`

	// Filters on which Pipeline packages to include in the deployed graph.  This block consists of following attributes:
	Filters []FiltersInitParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// The definition of a gateway pipeline to support CDC. Consists of following attributes:
	GatewayDefinition []GatewayDefinitionInitParameters `json:"gatewayDefinition,omitempty" tf:"gateway_definition,omitempty"`

	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	IngestionDefinition []IngestionDefinitionInitParameters `json:"ingestionDefinition,omitempty" tf:"ingestion_definition,omitempty"`

	LastModified *float64 `json:"lastModified,omitempty" tf:"last_modified,omitempty"`

	LatestUpdates []LatestUpdatesInitParameters `json:"latestUpdates,omitempty" tf:"latest_updates,omitempty"`

	// Specifies pipeline code and required artifacts. Syntax resembles library configuration block with the addition of a special notebook & file library types that should have the path attribute. Right now only the
	Library []PipelineLibraryInitParameters `json:"library,omitempty" tf:"library,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Notification []NotificationInitParameters `json:"notification,omitempty" tf:"notification,omitempty"`

	// A flag indicating whether to use Photon engine. The default value is false.
	Photon *bool `json:"photon,omitempty" tf:"photon,omitempty"`

	RestartWindow []RestartWindowInitParameters `json:"restartWindow,omitempty" tf:"restart_window,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	RunAsUserName *string `json:"runAsUserName,omitempty" tf:"run_as_user_name,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// An optional flag indicating if serverless compute should be used for this DLT pipeline.  Requires catalog to be set, as it could be used only with Unity Catalog.
	Serverless *bool `json:"serverless,omitempty" tf:"serverless,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// A location on DBFS or cloud storage where output data and metadata required for pipeline execution are stored. By default, tables are stored in a subdirectory of this location. Change of this parameter forces recreation of the pipeline. (Conflicts with catalog).
	Storage *string `json:"storage,omitempty" tf:"storage,omitempty"`

	// The name of a database (in either the Hive metastore or in a UC catalog) for persisting pipeline output data. Configuring the target setting allows you to view and query the pipeline output data from the Databricks UI.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	Trigger []PipelineTriggerInitParameters `json:"trigger,omitempty" tf:"trigger,omitempty"`

	// URL of the DLT pipeline on the given workspace.
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type PipelineLibraryInitParameters struct {
	File []LibraryFileInitParameters `json:"file,omitempty" tf:"file,omitempty"`

	Jar *string `json:"jar,omitempty" tf:"jar,omitempty"`

	Maven []PipelineLibraryMavenInitParameters `json:"maven,omitempty" tf:"maven,omitempty"`

	// & file types are supported.
	Notebook []NotebookInitParameters `json:"notebook,omitempty" tf:"notebook,omitempty"`

	Whl *string `json:"whl,omitempty" tf:"whl,omitempty"`
}

type PipelineLibraryMavenInitParameters struct {
	Coordinates *string `json:"coordinates,omitempty" tf:"coordinates,omitempty"`

	Exclusions []*string `json:"exclusions,omitempty" tf:"exclusions,omitempty"`

	Repo *string `json:"repo,omitempty" tf:"repo,omitempty"`
}

type PipelineLibraryMavenObservation struct {
	Coordinates *string `json:"coordinates,omitempty" tf:"coordinates,omitempty"`

	Exclusions []*string `json:"exclusions,omitempty" tf:"exclusions,omitempty"`

	Repo *string `json:"repo,omitempty" tf:"repo,omitempty"`
}

type PipelineLibraryMavenParameters struct {

	// +kubebuilder:validation:Optional
	Coordinates *string `json:"coordinates" tf:"coordinates,omitempty"`

	// +kubebuilder:validation:Optional
	Exclusions []*string `json:"exclusions,omitempty" tf:"exclusions,omitempty"`

	// +kubebuilder:validation:Optional
	Repo *string `json:"repo,omitempty" tf:"repo,omitempty"`
}

type PipelineLibraryObservation struct {
	File []LibraryFileObservation `json:"file,omitempty" tf:"file,omitempty"`

	Jar *string `json:"jar,omitempty" tf:"jar,omitempty"`

	Maven []PipelineLibraryMavenObservation `json:"maven,omitempty" tf:"maven,omitempty"`

	// & file types are supported.
	Notebook []NotebookObservation `json:"notebook,omitempty" tf:"notebook,omitempty"`

	Whl *string `json:"whl,omitempty" tf:"whl,omitempty"`
}

type PipelineLibraryParameters struct {

	// +kubebuilder:validation:Optional
	File []LibraryFileParameters `json:"file,omitempty" tf:"file,omitempty"`

	// +kubebuilder:validation:Optional
	Jar *string `json:"jar,omitempty" tf:"jar,omitempty"`

	// +kubebuilder:validation:Optional
	Maven []PipelineLibraryMavenParameters `json:"maven,omitempty" tf:"maven,omitempty"`

	// & file types are supported.
	// +kubebuilder:validation:Optional
	Notebook []NotebookParameters `json:"notebook,omitempty" tf:"notebook,omitempty"`

	// +kubebuilder:validation:Optional
	Whl *string `json:"whl,omitempty" tf:"whl,omitempty"`
}

type PipelineObservation struct {

	// Optional boolean flag. If false, deployment will fail if name conflicts with that of another pipeline. default is false.
	AllowDuplicateNames *bool `json:"allowDuplicateNames,omitempty" tf:"allow_duplicate_names,omitempty"`

	// optional string specifying ID of the budget policy for this DLT pipeline.
	BudgetPolicyID *string `json:"budgetPolicyId,omitempty" tf:"budget_policy_id,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	Catalog *string `json:"catalog,omitempty" tf:"catalog,omitempty"`

	Cause *string `json:"cause,omitempty" tf:"cause,omitempty"`

	// optional name of the release channel for Spark version used by DLT pipeline.  Supported values are: CURRENT (default) and PREVIEW.
	Channel *string `json:"channel,omitempty" tf:"channel,omitempty"`

	// Clusters to run the pipeline. If none is specified, pipelines will automatically select a default cluster configuration for the pipeline. Please note that DLT pipeline clusters are supporting only subset of attributes as described in   Also, note that autoscale block is extended with the mode parameter that controls the autoscaling algorithm (possible values are ENHANCED for new, enhanced autoscaling algorithm, or LEGACY for old algorithm).
	Cluster []PipelineClusterObservation `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// An optional list of values to apply to the entire pipeline. Elements must be formatted as key:value pairs.
	// +mapType=granular
	Configuration map[string]*string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// A flag indicating whether to run the pipeline continuously. The default value is false.
	Continuous *bool `json:"continuous,omitempty" tf:"continuous,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	CreatorUserName *string `json:"creatorUserName,omitempty" tf:"creator_user_name,omitempty"`

	// Deployment type of this pipeline. Supports following attributes:
	Deployment []PipelineDeploymentObservation `json:"deployment,omitempty" tf:"deployment,omitempty"`

	// A flag indicating whether to run the pipeline in development mode. The default value is false.
	Development *bool `json:"development,omitempty" tf:"development,omitempty"`

	// optional name of the product edition. Supported values are: CORE, PRO, ADVANCED (default).  Not required when serverless is set to true.
	Edition *string `json:"edition,omitempty" tf:"edition,omitempty"`

	ExpectedLastModified *float64 `json:"expectedLastModified,omitempty" tf:"expected_last_modified,omitempty"`

	// Filters on which Pipeline packages to include in the deployed graph.  This block consists of following attributes:
	Filters []FiltersObservation `json:"filters,omitempty" tf:"filters,omitempty"`

	// The definition of a gateway pipeline to support CDC. Consists of following attributes:
	GatewayDefinition []GatewayDefinitionObservation `json:"gatewayDefinition,omitempty" tf:"gateway_definition,omitempty"`

	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	IngestionDefinition []IngestionDefinitionObservation `json:"ingestionDefinition,omitempty" tf:"ingestion_definition,omitempty"`

	LastModified *float64 `json:"lastModified,omitempty" tf:"last_modified,omitempty"`

	LatestUpdates []LatestUpdatesObservation `json:"latestUpdates,omitempty" tf:"latest_updates,omitempty"`

	// Specifies pipeline code and required artifacts. Syntax resembles library configuration block with the addition of a special notebook & file library types that should have the path attribute. Right now only the
	Library []PipelineLibraryObservation `json:"library,omitempty" tf:"library,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Notification []NotificationObservation `json:"notification,omitempty" tf:"notification,omitempty"`

	// A flag indicating whether to use Photon engine. The default value is false.
	Photon *bool `json:"photon,omitempty" tf:"photon,omitempty"`

	RestartWindow []RestartWindowObservation `json:"restartWindow,omitempty" tf:"restart_window,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	RunAsUserName *string `json:"runAsUserName,omitempty" tf:"run_as_user_name,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// An optional flag indicating if serverless compute should be used for this DLT pipeline.  Requires catalog to be set, as it could be used only with Unity Catalog.
	Serverless *bool `json:"serverless,omitempty" tf:"serverless,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// A location on DBFS or cloud storage where output data and metadata required for pipeline execution are stored. By default, tables are stored in a subdirectory of this location. Change of this parameter forces recreation of the pipeline. (Conflicts with catalog).
	Storage *string `json:"storage,omitempty" tf:"storage,omitempty"`

	// The name of a database (in either the Hive metastore or in a UC catalog) for persisting pipeline output data. Configuring the target setting allows you to view and query the pipeline output data from the Databricks UI.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	Trigger []PipelineTriggerObservation `json:"trigger,omitempty" tf:"trigger,omitempty"`

	// URL of the DLT pipeline on the given workspace.
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type PipelineParameters struct {

	// Optional boolean flag. If false, deployment will fail if name conflicts with that of another pipeline. default is false.
	// +kubebuilder:validation:Optional
	AllowDuplicateNames *bool `json:"allowDuplicateNames,omitempty" tf:"allow_duplicate_names,omitempty"`

	// optional string specifying ID of the budget policy for this DLT pipeline.
	// +kubebuilder:validation:Optional
	BudgetPolicyID *string `json:"budgetPolicyId,omitempty" tf:"budget_policy_id,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	Catalog *string `json:"catalog,omitempty" tf:"catalog,omitempty"`

	// +kubebuilder:validation:Optional
	Cause *string `json:"cause,omitempty" tf:"cause,omitempty"`

	// optional name of the release channel for Spark version used by DLT pipeline.  Supported values are: CURRENT (default) and PREVIEW.
	// +kubebuilder:validation:Optional
	Channel *string `json:"channel,omitempty" tf:"channel,omitempty"`

	// Clusters to run the pipeline. If none is specified, pipelines will automatically select a default cluster configuration for the pipeline. Please note that DLT pipeline clusters are supporting only subset of attributes as described in   Also, note that autoscale block is extended with the mode parameter that controls the autoscaling algorithm (possible values are ENHANCED for new, enhanced autoscaling algorithm, or LEGACY for old algorithm).
	// +kubebuilder:validation:Optional
	Cluster []PipelineClusterParameters `json:"cluster,omitempty" tf:"cluster,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// An optional list of values to apply to the entire pipeline. Elements must be formatted as key:value pairs.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Configuration map[string]*string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// A flag indicating whether to run the pipeline continuously. The default value is false.
	// +kubebuilder:validation:Optional
	Continuous *bool `json:"continuous,omitempty" tf:"continuous,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	// +kubebuilder:validation:Optional
	CreatorUserName *string `json:"creatorUserName,omitempty" tf:"creator_user_name,omitempty"`

	// Deployment type of this pipeline. Supports following attributes:
	// +kubebuilder:validation:Optional
	Deployment []PipelineDeploymentParameters `json:"deployment,omitempty" tf:"deployment,omitempty"`

	// A flag indicating whether to run the pipeline in development mode. The default value is false.
	// +kubebuilder:validation:Optional
	Development *bool `json:"development,omitempty" tf:"development,omitempty"`

	// optional name of the product edition. Supported values are: CORE, PRO, ADVANCED (default).  Not required when serverless is set to true.
	// +kubebuilder:validation:Optional
	Edition *string `json:"edition,omitempty" tf:"edition,omitempty"`

	// +kubebuilder:validation:Optional
	ExpectedLastModified *float64 `json:"expectedLastModified,omitempty" tf:"expected_last_modified,omitempty"`

	// Filters on which Pipeline packages to include in the deployed graph.  This block consists of following attributes:
	// +kubebuilder:validation:Optional
	Filters []FiltersParameters `json:"filters,omitempty" tf:"filters,omitempty"`

	// The definition of a gateway pipeline to support CDC. Consists of following attributes:
	// +kubebuilder:validation:Optional
	GatewayDefinition []GatewayDefinitionParameters `json:"gatewayDefinition,omitempty" tf:"gateway_definition,omitempty"`

	// +kubebuilder:validation:Optional
	Health *string `json:"health,omitempty" tf:"health,omitempty"`

	// +kubebuilder:validation:Optional
	IngestionDefinition []IngestionDefinitionParameters `json:"ingestionDefinition,omitempty" tf:"ingestion_definition,omitempty"`

	// +kubebuilder:validation:Optional
	LastModified *float64 `json:"lastModified,omitempty" tf:"last_modified,omitempty"`

	// +kubebuilder:validation:Optional
	LatestUpdates []LatestUpdatesParameters `json:"latestUpdates,omitempty" tf:"latest_updates,omitempty"`

	// Specifies pipeline code and required artifacts. Syntax resembles library configuration block with the addition of a special notebook & file library types that should have the path attribute. Right now only the
	// +kubebuilder:validation:Optional
	Library []PipelineLibraryParameters `json:"library,omitempty" tf:"library,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Notification []NotificationParameters `json:"notification,omitempty" tf:"notification,omitempty"`

	// A flag indicating whether to use Photon engine. The default value is false.
	// +kubebuilder:validation:Optional
	Photon *bool `json:"photon,omitempty" tf:"photon,omitempty"`

	// +kubebuilder:validation:Optional
	RestartWindow []RestartWindowParameters `json:"restartWindow,omitempty" tf:"restart_window,omitempty"`

	// A user-friendly name for this pipeline. The name can be used to identify pipeline jobs in the UI.
	// +kubebuilder:validation:Optional
	RunAsUserName *string `json:"runAsUserName,omitempty" tf:"run_as_user_name,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// An optional flag indicating if serverless compute should be used for this DLT pipeline.  Requires catalog to be set, as it could be used only with Unity Catalog.
	// +kubebuilder:validation:Optional
	Serverless *bool `json:"serverless,omitempty" tf:"serverless,omitempty"`

	// +kubebuilder:validation:Optional
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// A location on DBFS or cloud storage where output data and metadata required for pipeline execution are stored. By default, tables are stored in a subdirectory of this location. Change of this parameter forces recreation of the pipeline. (Conflicts with catalog).
	// +kubebuilder:validation:Optional
	Storage *string `json:"storage,omitempty" tf:"storage,omitempty"`

	// The name of a database (in either the Hive metastore or in a UC catalog) for persisting pipeline output data. Configuring the target setting allows you to view and query the pipeline output data from the Databricks UI.
	// +kubebuilder:validation:Optional
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// +kubebuilder:validation:Optional
	Trigger []PipelineTriggerParameters `json:"trigger,omitempty" tf:"trigger,omitempty"`

	// URL of the DLT pipeline on the given workspace.
	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type PipelineTriggerInitParameters struct {
	Cron []CronInitParameters `json:"cron,omitempty" tf:"cron,omitempty"`

	Manual []ManualInitParameters `json:"manual,omitempty" tf:"manual,omitempty"`
}

type PipelineTriggerObservation struct {
	Cron []CronObservation `json:"cron,omitempty" tf:"cron,omitempty"`

	Manual []ManualParameters `json:"manual,omitempty" tf:"manual,omitempty"`
}

type PipelineTriggerParameters struct {

	// +kubebuilder:validation:Optional
	Cron []CronParameters `json:"cron,omitempty" tf:"cron,omitempty"`

	// +kubebuilder:validation:Optional
	Manual []ManualParameters `json:"manual,omitempty" tf:"manual,omitempty"`
}

type ReportInitParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// URL of the DLT pipeline on the given workspace.
	SourceURL *string `json:"sourceUrl,omitempty" tf:"source_url,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration []TableConfigurationInitParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type ReportObservation struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// URL of the DLT pipeline on the given workspace.
	SourceURL *string `json:"sourceUrl,omitempty" tf:"source_url,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration []TableConfigurationObservation `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type ReportParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationTable *string `json:"destinationTable,omitempty" tf:"destination_table,omitempty"`

	// URL of the DLT pipeline on the given workspace.
	// +kubebuilder:validation:Optional
	SourceURL *string `json:"sourceUrl,omitempty" tf:"source_url,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	// +kubebuilder:validation:Optional
	TableConfiguration []TableConfigurationParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type RestartWindowInitParameters struct {
	DaysOfWeek []*string `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	StartHour *float64 `json:"startHour,omitempty" tf:"start_hour,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	TimeZoneID *string `json:"timeZoneId,omitempty" tf:"time_zone_id,omitempty"`
}

type RestartWindowObservation struct {
	DaysOfWeek []*string `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	StartHour *float64 `json:"startHour,omitempty" tf:"start_hour,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	TimeZoneID *string `json:"timeZoneId,omitempty" tf:"time_zone_id,omitempty"`
}

type RestartWindowParameters struct {

	// +kubebuilder:validation:Optional
	DaysOfWeek []*string `json:"daysOfWeek,omitempty" tf:"days_of_week,omitempty"`

	// +kubebuilder:validation:Optional
	StartHour *float64 `json:"startHour" tf:"start_hour,omitempty"`

	// Canonical unique identifier of the DLT pipeline.
	// +kubebuilder:validation:Optional
	TimeZoneID *string `json:"timeZoneId,omitempty" tf:"time_zone_id,omitempty"`
}

type SchemaInitParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	SourceSchema *string `json:"sourceSchema,omitempty" tf:"source_schema,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration []SchemaTableConfigurationInitParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type SchemaObservation struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	SourceSchema *string `json:"sourceSchema,omitempty" tf:"source_schema,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	TableConfiguration []SchemaTableConfigurationObservation `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type SchemaParameters struct {

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	DestinationCatalog *string `json:"destinationCatalog,omitempty" tf:"destination_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	DestinationSchema *string `json:"destinationSchema,omitempty" tf:"destination_schema,omitempty"`

	// The name of catalog in Unity Catalog. Change of this parameter forces recreation of the pipeline. (Conflicts with storage).
	// +kubebuilder:validation:Optional
	SourceCatalog *string `json:"sourceCatalog,omitempty" tf:"source_catalog,omitempty"`

	// The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
	// +kubebuilder:validation:Optional
	SourceSchema *string `json:"sourceSchema,omitempty" tf:"source_schema,omitempty"`

	// Configuration settings to control the ingestion of tables. These settings are applied to all tables in the pipeline.
	// +kubebuilder:validation:Optional
	TableConfiguration []SchemaTableConfigurationParameters `json:"tableConfiguration,omitempty" tf:"table_configuration,omitempty"`
}

type SchemaTableConfigurationInitParameters struct {
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type SchemaTableConfigurationObservation struct {
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type SchemaTableConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	// +kubebuilder:validation:Optional
	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	// +kubebuilder:validation:Optional
	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	// +kubebuilder:validation:Optional
	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableConfigurationInitParameters struct {
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableConfigurationObservation struct {
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	// +kubebuilder:validation:Optional
	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	// +kubebuilder:validation:Optional
	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	// +kubebuilder:validation:Optional
	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableTableConfigurationInitParameters struct {
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableTableConfigurationObservation struct {
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

type TableTableConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	PrimaryKeys []*string `json:"primaryKeys,omitempty" tf:"primary_keys,omitempty"`

	// +kubebuilder:validation:Optional
	SalesforceIncludeFormulaFields *bool `json:"salesforceIncludeFormulaFields,omitempty" tf:"salesforce_include_formula_fields,omitempty"`

	// +kubebuilder:validation:Optional
	ScdType *string `json:"scdType,omitempty" tf:"scd_type,omitempty"`

	// +kubebuilder:validation:Optional
	SequenceBy []*string `json:"sequenceBy,omitempty" tf:"sequence_by,omitempty"`
}

// PipelineSpec defines the desired state of Pipeline
type PipelineSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PipelineParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider PipelineInitParameters `json:"initProvider,omitempty"`
}

// PipelineStatus defines the observed state of Pipeline.
type PipelineStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PipelineObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Pipeline is the Schema for the Pipelines API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,databricks}
type Pipeline struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              PipelineSpec   `json:"spec"`
	Status            PipelineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PipelineList contains a list of Pipelines
type PipelineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Pipeline `json:"items"`
}

// Repository type metadata.
var (
	Pipeline_Kind             = "Pipeline"
	Pipeline_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Pipeline_Kind}.String()
	Pipeline_KindAPIVersion   = Pipeline_Kind + "." + CRDGroupVersion.String()
	Pipeline_GroupVersionKind = CRDGroupVersion.WithKind(Pipeline_Kind)
)

func init() {
	SchemeBuilder.Register(&Pipeline{}, &PipelineList{})
}

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type RepoInitParameters struct {

	// name of the branch for initial checkout. If not specified, the default branch of the repository will be used.  Conflicts with tag.  If branch is removed, and tag isn't specified, then the repository will stay at the previously checked out state.
	Branch *string `json:"branch,omitempty" tf:"branch,omitempty"`

	// Hash of the HEAD commit at time of the last executed operation. It won't change if you manually perform pull operation via UI or API
	CommitHash *string `json:"commitHash,omitempty" tf:"commit_hash,omitempty"`

	// case insensitive name of the Git provider.  Following values are supported right now (could be a subject for a change, consult Repos API documentation): gitHub, gitHubEnterprise, bitbucketCloud, bitbucketServer, azureDevOpsServices, gitLab, gitLabEnterpriseEdition, awsCodeCommit.
	GitProvider *string `json:"gitProvider,omitempty" tf:"git_provider,omitempty"`

	// path to put the checked out Git folder. If not specified, , then the Git folder will be created in the default location.  If the value changes, Git folder is re-created.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	SparseCheckout []SparseCheckoutInitParameters `json:"sparseCheckout,omitempty" tf:"sparse_checkout,omitempty"`

	// name of the tag for initial checkout.  Conflicts with branch.
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`

	// The URL of the Git Repository to clone from. If the value changes, Git folder is re-created.
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type RepoObservation struct {

	// name of the branch for initial checkout. If not specified, the default branch of the repository will be used.  Conflicts with tag.  If branch is removed, and tag isn't specified, then the repository will stay at the previously checked out state.
	Branch *string `json:"branch,omitempty" tf:"branch,omitempty"`

	// Hash of the HEAD commit at time of the last executed operation. It won't change if you manually perform pull operation via UI or API
	CommitHash *string `json:"commitHash,omitempty" tf:"commit_hash,omitempty"`

	// case insensitive name of the Git provider.  Following values are supported right now (could be a subject for a change, consult Repos API documentation): gitHub, gitHubEnterprise, bitbucketCloud, bitbucketServer, azureDevOpsServices, gitLab, gitLabEnterpriseEdition, awsCodeCommit.
	GitProvider *string `json:"gitProvider,omitempty" tf:"git_provider,omitempty"`

	// Git folder identifier
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// path to put the checked out Git folder. If not specified, , then the Git folder will be created in the default location.  If the value changes, Git folder is re-created.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	SparseCheckout []SparseCheckoutObservation `json:"sparseCheckout,omitempty" tf:"sparse_checkout,omitempty"`

	// name of the tag for initial checkout.  Conflicts with branch.
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`

	// The URL of the Git Repository to clone from. If the value changes, Git folder is re-created.
	URL *string `json:"url,omitempty" tf:"url,omitempty"`

	// path on Workspace File System (WSFS) in form of /Workspace + path
	WorkspacePath *string `json:"workspacePath,omitempty" tf:"workspace_path,omitempty"`
}

type RepoParameters struct {

	// name of the branch for initial checkout. If not specified, the default branch of the repository will be used.  Conflicts with tag.  If branch is removed, and tag isn't specified, then the repository will stay at the previously checked out state.
	// +kubebuilder:validation:Optional
	Branch *string `json:"branch,omitempty" tf:"branch,omitempty"`

	// Hash of the HEAD commit at time of the last executed operation. It won't change if you manually perform pull operation via UI or API
	// +kubebuilder:validation:Optional
	CommitHash *string `json:"commitHash,omitempty" tf:"commit_hash,omitempty"`

	// case insensitive name of the Git provider.  Following values are supported right now (could be a subject for a change, consult Repos API documentation): gitHub, gitHubEnterprise, bitbucketCloud, bitbucketServer, azureDevOpsServices, gitLab, gitLabEnterpriseEdition, awsCodeCommit.
	// +kubebuilder:validation:Optional
	GitProvider *string `json:"gitProvider,omitempty" tf:"git_provider,omitempty"`

	// path to put the checked out Git folder. If not specified, , then the Git folder will be created in the default location.  If the value changes, Git folder is re-created.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	SparseCheckout []SparseCheckoutParameters `json:"sparseCheckout,omitempty" tf:"sparse_checkout,omitempty"`

	// name of the tag for initial checkout.  Conflicts with branch.
	// +kubebuilder:validation:Optional
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`

	// The URL of the Git Repository to clone from. If the value changes, Git folder is re-created.
	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`
}

type SparseCheckoutInitParameters struct {

	// array of paths (directories) that will be used for sparse checkout.  List of patterns could be updated in-place.
	Patterns []*string `json:"patterns,omitempty" tf:"patterns,omitempty"`
}

type SparseCheckoutObservation struct {

	// array of paths (directories) that will be used for sparse checkout.  List of patterns could be updated in-place.
	Patterns []*string `json:"patterns,omitempty" tf:"patterns,omitempty"`
}

type SparseCheckoutParameters struct {

	// array of paths (directories) that will be used for sparse checkout.  List of patterns could be updated in-place.
	// +kubebuilder:validation:Optional
	Patterns []*string `json:"patterns" tf:"patterns,omitempty"`
}

// RepoSpec defines the desired state of Repo
type RepoSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RepoParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider RepoInitParameters `json:"initProvider,omitempty"`
}

// RepoStatus defines the observed state of Repo.
type RepoStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RepoObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Repo is the Schema for the Repos API. ""subcategory: "Workspace"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,}
type Repo struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.url) || (has(self.initProvider) && has(self.initProvider.url))",message="spec.forProvider.url is a required parameter"
	Spec   RepoSpec   `json:"spec"`
	Status RepoStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RepoList contains a list of Repos
type RepoList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Repo `json:"items"`
}

// Repository type metadata.
var (
	Repo_Kind             = "Repo"
	Repo_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Repo_Kind}.String()
	Repo_KindAPIVersion   = Repo_Kind + "." + CRDGroupVersion.String()
	Repo_GroupVersionKind = CRDGroupVersion.WithKind(Repo_Kind)
)

func init() {
	SchemeBuilder.Register(&Repo{}, &RepoList{})
}
